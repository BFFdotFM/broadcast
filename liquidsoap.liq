# Exported from AzuraCast — to deploy, extract the marked BEGIN/END sections into the AzuraCast editor.

# WARNING! This file is automatically generated by AzuraCast.
# Do not update it directly!

set("init.daemon", false)
set("init.daemon.pidfile.path","/var/azuracast/stations/testfm/config/liquidsoap.pid")
set("log.stdout", true)
set("log.file", false)
set("server.telnet",true)
set("server.telnet.bind_addr","0.0.0.0")
set("server.telnet.port", 8014)
set("harbor.bind_addrs",["0.0.0.0"])

set("tag.encodings",["UTF-8","ISO-8859-1"])
set("encoder.encoder.export",["artist","title","album","song"])

setenv("TZ", "America/Los_Angeles")

azuracast_api_auth = ref "(PASSWORD)"
ignore(azuracast_api_auth)

autodj_is_loading = ref true
ignore(autodj_is_loading)

autodj_ping_attempts = ref 0
ignore(autodj_ping_attempts)

# Custom Configuration (Specified in Station Profile)

### Secrets should not be checked in. Duh.
### BEGIN: BFF.fm Configuration and Secrets ###

azuracast_station_id = ref(5)

# Creek CMS integration
creek_app_id = ref("")
creek_api_base = ref("")
creek_public_base = ref("")

# Harbor Ingest configuration
ingest_icecast_port = ref(8015)

# Ingest precedence stacks all created HTTP harbors (by name) to create the cascade by which on-air is determined.
# The names need to match the names of ingest sources created later.
# TODO: DRY: Find a clean way to build this list implicitly
ingest_channel_precedence = ref([
  "Emergency Broadcast",
  "Remote DJ",
  "Studio F",
  "Studio A",
  "Studio Automation"
])

ingest_studio_a_password = ref("")
ingest_studio_f_password = ref("")
ingest_automation_password = ref("")

# Configure Last.FM scrobbling
lastfm_app_id = ref("")
lastfm_app_secret = ref("")
lastfm_session_token = ref("")

# Prefix all Slack logs with this text:
slack_message_prefix = ref(":safety_vest: ")
slack_default_channel = ref("") # ABC/DEF/fafas23 webhook
slack_named_channels = ref([
  ("alerts", slack_default_channel),
  ("stream_auth", slack_default_channel),
  ("now_playing", ref(""))
])

tunein_partner_id = ref("")
tunein_partner_key =  ref("")
tunein_station_id = ref("")

user_agent_name = ref("BFF.fm Broadcast System")
user_agent_url = ref("https://bff.fm")

### END: BFF.fm Configuration and Secrets ###

### BEGIN: BFF.fm Library Code ###

## Time Utilities
# Shorthands for various time formats from the system time

let timestamp = ()

def timestamp.custom(format="%T") =
  list.hd(get_process_lines(env=[("TZ", ":America/Los_Angeles"), ("FORMAT", format)], "date +$FORMAT"), default="")
end

def timestamp.hms() =
  timestamp.custom("%T")
end

def timestamp.iso8609() =
  timestamp.custom("%Y-%m-%dT%H:%M:%S")
end

def timestamp.ymdhms() =
  timestamp.custom("%Y%m%dT%H%M%S")
end

def timestamp.unix() =
  timestamp.custom("%s")
end

## Hash and Crypto

let hash = ()

def hash.md5 =
  md5sum = which("md5sum")
  log.debug("Path to md5sum: #{md5sum}")
  # md5sum returns the form "<HASH> -", so split away just the hash w/ awk:
  list.hd(get_process_lines(env=[("STR", str)], "printf %s \"$STR\" | #{md5sum} | awk '{ print $1 }'"), default="")
end

## Curl HTTP functions
# We need to POST and GET data via CURL, these wrappers provide some sugar around the build-in http.get/post

let curl = ()
let curl.version = ref(list.hd(get_process_lines(env=[("STR", str)], "curl --version | head -1 | awk '{ print $1 "/" $2 }'"), default="curl/unknown"))
let curl.userAgent = ref("LiquidSoap/#{liquidsoap.version} (#{!curl.version}) #{!user_agent_name} <#{!user_agent_url}>")

def curl.json(~data=[], ~timeout_ms=2000, url) =
  http.post(url,
    headers=[
      ("User-Agent", !curl.userAgent),
      ("Content-Type", "application/json")
    ]),
    timeout_ms=timeout_ms,
    data=json.stringify(data)
  )
end

def curl.post(~data=[], ~timeout_ms=2000, url) =
  def buildDataString(data, arg) =
    data ^ fst(arg) ^ "=" ^ url.encode(snd(arg)) ^ "&"
  end
  formData = list.fold(buildDataString, "", data)

  http.post(url,
    headers=[
      ("User-Agent", !curl.userAgent),
      ("Content-Type": "application/x-www-form-urlencoded")
    ]),
    timeout_ms=timeout_ms,
    data=formData
  )
end

def curl.fetch(~timeout_ms=2000, url) =
  http.get(url, headers=[("User-Agent", !curl.userAgent)], timeout_ms=timeout_ms)
end

## BFF.fm API functions
#
# BFF.fm CMS is a forked version of Creek, along with some of our own deployment idiocyncracies,
# so this wrapper makes calling the API easier
let bff = ()
let bff.appId = creek_app_id
let bff.base = creek_api_base
let bff.publicBase = creek_public_base

def bff.fetch(~cacheBust=false, endpoint)
  appendUrl = if (cacheBust == true) then
    "&cacheBust=#{timestamp.unix()}"
  else
    ""
  end

  fullApiCallUrl = "#{!bff.base}/api/#{endpoint}?app_id=#{url.encode(!bff.appId)}#{appendUrl}"
  response = curl.fetch(fullApiCallUrl)

  if (response.status_code == 200) then
    "#{response}"
  else
    ""
  end
end

def bff.post(~data=[], endpoint)
  url = "#{!bff.base}/api/#{endpoint}"
  fullData = list.append([
    ('app_id', !bff.appId)
  ], data)
  response = curl.post(data=fullData, url)

  if (response.status_code == 200) then
    "#{response}"
  else
    ""
  end
end

# Create a special "now" endpoint shortlink that will direct users to the most relevant show/broadcast
# destination based on the time of the URL:
#
# e.g. https://bff.fm/now/20200209T115500
def bff.nowUrl() =
  "#{creek_public_base}/now/#{timestamp.ymdhms()}"
end

## Slack Functions
# BFF.fm makes heavy use of Slack for all our community organizing and a lot of technical monitoring.

let slack = ()

# Configure as pairs of named channels, plus the unique `ABCD/1234` part of the WebHook URL configured
# through an app at https://api.slack.com/apps
#
# You must specify a default.
let slack.defaultChannel = slack_default_channel
let slack.channels = slack_named_channels
let slack.messagePrefix = slack_message_prefix

def slack.send(hook, message) =
  payload = [("text", "[#{timestamp.hms()}] #{!slack.messagePrefix}#{message}"), ("type", "mrkdwn")]
  ignore(curl.json(data=payload, "https://hooks.slack.com/services/#{hook}"))
end

def slack.log(~channel = "", message) =
  channelHook = list.assoc(default=slack.defaultChannel, channel, !slack.channels)
  ignore(slack.send(channelHook, message))
end

## Last.FM Functions
#
# Last.FM integration can also be provided via an extension for LiquidSoap, but it's not shipping in AzuraCast at this
# time, so we implemented the `track.scrobble` API ourselves.
#
# You'll need to create an app at https://www.last.fm/api and then auth your account against it to get a Session token
# and store it all in the config above.
let lastfm = ()

let lastfm.apiBase = ref("https://ws.audioscrobbler.com/2.0/")
let lastfm.appId = lastfm_app_id
let lastfm.appSecret = lastfm_app_secret
let lastfm.sessionToken = lastfm_session_token

def lastfm.scrobble(~artist, ~track, ~album="") =

  log.info("Scrobbling: #{track} by #{artist} (Album: #{album})")

  # parameters in alphabetical order
  params = [
    ("album", album),
    ("api_key", !lastfm.appId),
    ("artist", artist),
    ("method", "track.scrobble"),
    ("sk", !lastfm.sessionToken),
    ("timestamp", timestamp.unix()),
    ("track", track),
  ]

  def flattenSignatureParam(output, p) =
    output ^ fst(p) ^ snd(p)
  end

  hashableParamString = list.fold(flattenSignatureParam, "", params) ^ !lastfm.appSecret
  apiSignature = hash.md5(hashableParamString)
  fullParams = list.append(params, [("api_sig", apiSignature)])
  ignore(curl.post(data=fullParams, !lastfm.apiBase))
end

# While we now pull our playing data from a richer JSON API, this function handles the common
# Artist - Track string format that might be passed around your automation system.
def lastfm.scrobbleNowPlayingString(nowPlaying) =
  parts = list.map(string.trim, string.split(separator="-", nowPlaying))

  if (list.length(parts) == 2) then
    artist = list.hd(default="", parts)
    track = list.nth(default="", parts, 1)
    lastfm.scrobble(artist=artist, track=track)
  else
    log.important("Could not attempt scrobbling #{nowPlaying}, did not split into 2 parts")
  end
end

## TuneIn AIR Support
# AzuraCast does have some native support for TuneIN, but since we're pulling richer track
# metadata (see below), we've implemented it directly.

let tunein = ()
let tunein.apiBase = ref("http://air.radiotime.com/Playing.ashx")
let tunein.partnerId = tunein_partner_id
let tunein.partnerKey = tunein_partner_key
let tunein.stationId = tunein_station_id

def tunein.airRequest(params) =
  fullParams = list.append([
    ("partnerId", !tunein.partnerId),
    ("partnerKey", !tunein.partnerKey),
    ("id", !tunein.stationId)
  ], params)
  ignore(curl.post(data=fullParams, !tunein.apiBase))
end

def tunein.nowPlaying(~artist, ~track, ~album="") =
  log.info("Logging to TuneIn AIR NOW: #{track} by #{artist} (Album: #{album})")
  tunein.airRequest([
    ("artist", artist),
    ("title", track),
    ("album", album)
  ])
end

def tunein.nonMusic(~attribution, ~name) =
  log.info("Logging non-music to TuneIn AIR NOW: #{name} attributed to #{attribution}")
  tunein.airRequest([
    ("artist", attribution),
    ("title", name),
#    ("commercial", "true")
  ])
end

## Twitter Support
# Support composing Tweets

let twitter = ()
let twitter.apiBase = ref("https://api.twitter.com")
let twitter.consumeKey = ref("")
let twitter.consumerSecret = ref("")
let twitter.userToken = ref("")
let twitter.userTokenSecret = ref("")

def twitter.tweet(message) =
  log.info("Twitter: Not Impemented Yet")
  "Twitter: Not Impemented Yet"
end

### END: BFF.fm Library Code ###

playlist_default = playlist(id="playlist_default",mode="randomize",reload_mode="watch",conservative=true,default_duration=10.,length=20.,"/var/azuracast/stations/testfm/playlists/playlist_default.m3u")
playlist_default = audio_to_stereo(id="stereo_playlist_default", playlist_default)
playlist_default = cue_cut(id="cue_playlist_default", playlist_default)

# Standard Playlists
radio = random(id="standard_playlists", weights=[3], [playlist_default])

requests = request.queue(id="requests")
requests = audio_to_stereo(id="stereo_requests", requests)
requests = cue_cut(id="cue_requests", requests)

radio = fallback(id="requests_fallback", track_sensitive = true, [requests, radio])
add_skip_command(radio)

radio = crossfade(smart=false, duration=3.00,fade_out=2.00,fade_in=2.00,radio)

### BEGIN: BFF.fm drop default metadata  ###

# Custom Configuration (Specified in Station Profile)
# Drop the default Azuracast fallback metadata
radio = drop_metadata(radio)

### END: BFF.fm drop default metadata  ###

# DJ Authentication
live_enabled = ref false
last_authenticated_dj = ref ""
live_dj = ref ""

def dj_auth(auth_user,auth_pw) =
    user = ref ""
    password = ref ""

    if (auth_user == "source" or auth_user == "") and (string.match(pattern="(:|,)+", auth_pw)) then
        auth_string = string.split(separator="(:|,)", auth_pw)

        user := list.nth(default="", auth_string, 0)
        password := list.nth(default="", auth_string, 2)
    else
        user := auth_user
        password := auth_pw
    end

    log("Authenticating DJ: #{!user}")

    ret = list.hd(get_process_lines(env=[("DJ_USER", !user), ("DJ_PASSWORD", !password), ("API_AUTH", !azuracast_api_auth)], 'curl -s --request POST --url http://web/api/internal/5/auth --form dj-user="$DJ_USER" --form dj-password="$DJ_PASSWORD" --form api_auth="$API_AUTH"'), default="")
    log("AzuraCast DJ Auth Response: #{ret}")

    authed = bool_of_string(ret)
    if (authed) then
        last_authenticated_dj := !user
    end

    authed
end

def live_connected(header) =
    dj = !last_authenticated_dj
    log("DJ Source connected! Last authenticated DJ: #{dj} - #{header}")

    live_enabled := true
    live_dj := dj

    ret = list.hd(get_process_lines(env=[("DJ_USER", dj), ("API_AUTH", !azuracast_api_auth)], 'curl -s --request POST --url http://web/api/internal/5/djon --form dj-user="$DJ_USER" --form api_auth="$API_AUTH"'), default="")
    log("AzuraCast Live Connected Response: #{ret}")
end

def live_disconnected() =
    dj = !live_dj

    log("DJ Source disconnected! Current live DJ: #{dj}")

    ret = list.hd(get_process_lines(env=[("DJ_USER", dj), ("API_AUTH", !azuracast_api_auth)], 'curl -s --request POST --url http://web/api/internal/5/djoff --form dj-user="$DJ_USER" --form api_auth="$API_AUTH"'), default="")
    log("AzuraCast Live Disconnected Response: #{ret}")

    live_enabled := false
    last_authenticated_dj := ""
    live_dj := ""
end

# A Pre-DJ source of radio that can be broadcast if needed',
radio_without_live = radio
ignore(radio_without_live)

# Live Broadcasting
live = audio_to_stereo(input.harbor("/autodj/", id = "input_streamer", port = 8015, auth = dj_auth, icy = true, icy_metadata_charset = "UTF-8", metadata_charset = "UTF-8", on_connect = live_connected, on_disconnect = live_disconnected, buffer = 5.00, max = 10.00))
ignore(output.dummy(live, fallible=true))

radio = fallback(id="live_fallback", replay_metadata=false, track_sensitive=false, [live, radio])

# Allow for Telnet-driven insertion of custom metadata.
radio = server.insert_metadata(id="custom_metadata", radio)

# Apply amplification metadata (if supplied)
radio = amplify(override="liq_amplify", 1., radio)

radio = fallback(id="safe_fallback", track_sensitive = false, [radio, single(id="error_jingle", "/usr/local/share/icecast/web/error.mp3")])

# Custom Configuration (Specified in Station Profile)

### BEGIN: BFF.fm Ingest Harbors ###

# Reset the above and remove the default Azuracast autodj mount from the
ignore(radio)

# If running an automation playlist through AzuraCast, assign `radio_without_live` instead
radio = single(id="no_broadcast", "/usr/local/share/icecast/web/error.mp3")

# Manage Icecast input harbors remote DJs and Studios
let ingest = ()

ingest.icecastPort = ingest_icecast_port
# Precedence needs to match the names of ingest sources created below.
# TODO: DRY: Refactor so that this is implicit based on the create of channels below.
let ingest.precedence = ingest_channel_precedence
let ingest.connections = ref([])

# Is a named studio currently connected?
def ingest.isConnected(studio) =
  dj = list.assoc(default="", studio, !ingest.connections)
  (dj != "")
end

# Who is connected to a named studio?
def ingest.djFor(studio) =
  def listToString(str, item) =
    str ^ "#{fst(item)} => #{snd(item)}"
  end
  connectionsDebug = list.fold(listToString, "", !ingest.connections)
  log.debug("Connections: #{connectionsDebug}")

  list.assoc(default="", studio, !ingest.connections)
end

# Who is the current on-air DJ, based on studio precedence?
def ingest.currentDj() =
  # Get the DJ for the highest precedence studio that has a DJ
  def getDj(current, studio) =
    if (current != "") then
      current
    else
      ingest.djFor(studio)
    end
  end
  list.fold(getDj, "", !ingest.precedence)
end

# Global “on connection” handler
def ingest.onDjConnect() =
  dj_name = ingest.currentDj()
  if (dj_name != "") then
    _ = azuracast_api_call(
      timeout_ms=5000,
      "djon",
      json.stringify({user = dj_name})
    )
    #log.debug("AzuraCast remote DJ connected response: #{ret}")
    slack.log(":rotating_light: ON AIR: *#{dj_name}*")
  end
end

# Global “on disconnect handler
def ingest.onDjDisconnect() =
  dj_name = ingest.currentDj()
  log.debug("Source disconnected. Current broadcaster was: #{dj_name}")

  if (dj_name != "") then
    _ = azuracast_api_call(
      timeout_ms=5000,
      "djoff",
      json.stringify({user = !dj_name})
    )
  end
end

# Handle parsing of username:password strings from legacy clients
def ingest.parseCredentials(login) =
  if (login.user == "source" or login.user == "") and (string.match(pattern="(:|,)+", login.password)) then
    auth_string = string.split(separator="(:|,)", login.password)
    {user = list.nth(default="", auth_string, 0),
    password = list.nth(default="", auth_string, 2)}
  else
    {user = login.user, password = login.password}
  end
end

# Create a studio source
# — These sources have a single fixed password baked into the configuration.
def ingest.makeStudioSource(studioName, ~mount, ~username="source", ~password, ~dropMetadata=false) =
  def studioAuth(login) =
    input_user = ref("")
    input_password = ref("")
    auth_info = ingest.parseCredentials(login)

    if ((!auth_info.user == username) and (!auth_info.password == password )) then
      ingest.connections := list.add((studioName, username), !ingest.connections)
      log.info("Studio connected: #{username}")
      true
    else
      ingest.connections := list.remove_assoc(studioName, !ingest.connections)
      log.important("Studio authentication failed: #{username}")
      false
    end
  end

  # When a studio connects, announce to monitoring destinations
  def connected(header) =
    log.info("#{studioName} source connected!")
    slack.log(":zap: #{studioName} source connected (*#{ingest.djFor(studioName)}*)")

    # Trigger global connection handler, which will update on-air metadata if
    # this studio is top of the precedence stack
    ingest.onDjConnect()
  end

  # When a studio disconnects, announce to monitoring destinations
  def disconnected() =
    log("#{studioName} disconnected!")
    slack.log(":end: #{studioName} disconnected (*#{ingest.djFor(studioName)}*)")
    ingest.onDjDisconnect()

    # Clear studio DJ variables
    ingest.connections = list.remove_assoc(studioName, !ingest.connections)

    # Reset metadata for other remaining connected streams
    ingest.onDjConnect()
  end

  # Create an IceCast harbor for this studio
  harbor = audio_to_stereo(input.harbor(mount, port = !ingest.icecastPort, auth = studioAuth, icy = true, icy_metadata_charset = "UTF-8", metadata_charset = "UTF-8", on_connect = connected, on_disconnect = disconnected, buffer = 10., max = 15.))
  ignore(output.dummy(harbor, fallible=true))

  # return the source
  if (dropMetadata == true) then
    drop_metadata(harbor)
  else
    harbor
  end
end

# Create an remote DJ source authenticated against AzuraCast's 'streamers' database
def ingest.makeAzuraCastStreamerSource(studioName, ~mount, ~dropMetadata=false) =
  # Keep track of who the last DJ was so we can monitor when it changes.
  lastDj = ref("")

  def azuracastAuth(login) =
    auth_info = ingest.parseCredentials(login)
    response = azuracast_api_call(
      timeout_ms=5000,
      "auth",
      json.stringify(auth_info)
    )
    authed = bool_of_string(response)

    if (authed) then
      lastDj := !auth_info.user
      log.debug("Set lastDj to: #{!lastDj} (#{!auth_info.user})")
    else
      log.important("Remote DJ authentication failed: #{!auth_info.user} authentication returned false")
    end

    authed
  end

  def remote_connected(header) =
    dj = !lastDj
    log.debug("Adding (#{studioName}, #{dj}) pair to active connections")
    ingest.connections := list.add((studioName, dj), !ingest.connections)

    def listToString(str, item) =
      str ^ "#{fst(item)} => #{snd(item)}"
    end
    connectionsDebug = list.fold(listToString, "", !ingest.connections)
    log.debug("Connections After Add: #{connectionsDebug}")

    log.info("#{studioName} connected! DJ: #{dj} - #{header}")

    # Announce source connection
    slack.log(":zap: #{studioName} source connected (*#{ingest.djFor(studioName)}*)")

    # Trigger global connection handler, which will update on-air metadata if
    # this source is top of the precedence stack
    ingest.onDjConnect()
  end

  def remote_disconnected() =
    log.debug("Remote Disconnected")
    dj = ingest.djFor(studioName)

    log("Remote DJ source disconnected! Was: #{dj}")
    slack.log(":end: #{studioName} disconnected (*#{dj}* :micdrop:)")

    ingest.onDjDisconnect()

    # Clear studio DJ variables
    ingest.connections := list.remove_assoc(studioName, !ingest.connections)

    # Reset metadata for other remaining connected streams
    ingest.onDjConnect()
  end

  harbor = audio_to_stereo(input.harbor(mount, port = !ingest.icecastPort, auth = azuracastAuth, icy = true, icy_metadata_charset = "UTF-8", metadata_charset = "UTF-8", on_connect = remote_connected, on_disconnect = remote_disconnected, buffer = 10., max = 15.))
  ignore(output.dummy(harbor, fallible=true))

  # return the source
  if (dropMetadata == true) then
    drop_metadata(harbor)
  else
    harbor
  end
end

# Create an remote DJ source authenticated against Creek's user database
def ingest.makeCreekStreamerSource(studioName, ~mount, ~dropMetadata=false, ~authEndpoint="/api/auth/stream") =
  # Keep track of who the last DJ was so we can monitor when it changes.
  lastDj = ref("")

  def creekAuth(login) =
    auth_info = ingest.parseCredentials(login)

    log.debug("Authenticating Creek DJ: #{auth_info.user}")

    ret = bff.post(authEndpoint, data=[
      ("username", auth_info.user),
      ("password", auth_info.password)
    ])
    log.debug("Creek DJ auth response: #{ret}")

    result = json.parse(default=[("authenticated", false)], ret)
    resultContent = json.parse(default=[("foo", "bar")], ret)

    authed = list.assoc(default=false, "authenticated", result)

    if (authed) then
      djName = list.assoc(default=!user, "display_name", resultContent)
      showName = list.assoc(default="", "show", resultContent)
      endTime = list.assoc(default="", "end_time", resultContent)

      lastDj := "#{djName}/#{showName} (#{!user})"
      log.debug("Set lastDj to: #{!lastDj}")

      slack.log(":key: #{studioName} DJ authenticated: *#{djName}*/*#{showName}* (@#{!user})")
      slack.log("@#{!user}} :clock10: Remember to disconnected before *#{endTime}* when #{showName} ends!")
    else
      # Auth failed, get reason and push to Slack:
      reason = list.assoc(default="Unspecified authentication error; possible server error.", "reason", resultContent)
      slack.log(":octagonal_sign: #{studioName} DJ authentication failed: Creek user @#{!user} not authenticated because: *#{reason}*")
      log.important("Creek DJ #{!user} authentication failed: #{reason}")
    end

    authed
  end

  def remote_connected(header) =
    dj = !lastDj
    log.debug("Adding (#{studioName}, #{dj}) pair to active connections")
    ingest.connections := list.add((studioName, dj), !ingest.connections)

    def listToString(str, item) =
      str ^ "#{fst(item)} => #{snd(item)}"
    end
    connectionsDebug = list.fold(listToString, "", !ingest.connections)
    log.debug("Connections After Add: #{connectionsDebug}")

    log.info("#{studioName} connected! DJ: #{dj} - #{header}")

    # Announce source connection
    slack.log(":zap: #{studioName} source connected (*#{ingest.djFor(studioName)}*)")

    # Trigger global connection handler, which will update on-air metadata if
    # this source is top of the precedence stack
    ingest.onDjConnect()
  end

  def remote_disconnected() =
    log.debug("Remote Disconnected")
    dj = ingest.djFor(studioName)

    log("Remote DJ source disconnected! Was: #{dj}")
    slack.log(":end: #{studioName} disconnected (*#{dj}* :micdrop:)")

    ingest.onDjDisconnect()

    # Clear studio DJ variables
    ingest.connections := list.remove_assoc(studioName, !ingest.connections)

    # Reset metadata for other remaining connected streams
    ingest.onDjConnect()
  end

  harbor = audio_to_stereo(input.harbor(mount, port = !ingest.icecastPort, auth = azuracastAuth, icy = true, icy_metadata_charset = "UTF-8", metadata_charset = "UTF-8", on_connect = remote_connected, on_disconnect = remote_disconnected, buffer = 10., max = 15.))
  ignore(output.dummy(harbor, fallible=true))

  # return the source
  if (dropMetadata == true) then
    drop_metadata(harbor)
  else
    harbor
  end
end

dj_sources = fallback(track_sensitive=false, [
  ingest.makeAzuraCastStreamerSource("Remote DJ", mount="/dj", dropMetadata=true),
  ingest.makeStudioSource("Studio F DJ", mount="/ferry", password=!ingest_studio_a_password, dropMetadata=true),
  ingest.makeStudioSource("Studio A DJ", mount="/studio", password=!ingest_studio_f_password, dropMetadata=true),
  ingest.makeStudioSource("Studio Automation", mount="/automation", password=!ingest_automation_password, dropMetadata=true)
])

# Tracking metadata
#
# Regardless of where our source is connected from, we treat our CMS as the canonical and only source of truth for what
# music is being played. (Hence `dropMetadata=true` on all the Icecast ingestion above.)
#
# Here, we poll the CMS for track changes.

creek_metadata_source = insert_metadata(dj_sources)
dj_sources = creek_metadata_source

# For debugging purposes, we store the last unique track name, and the
# timestamp of when it was registered
last_creek_track = ref(("BFF.fm", timestamp.hms()))

def poll_creek_metadata() =
  last_name = fst(!last_creek_track)
  now = timestamp.hms()

  # Fetch the now playing track from BFF.fm API
  playing = bff.fetch(cacheBust=true, "data/tracks/now.json")
  log.debug("Fetched: #{playing}")

  playingData = json.parse(default=[("", "")], playing)
  artist = list.assoc(default="", "artist", playingData)
  title = list.assoc(default="", "title", playingData)
  album = list.assoc(default="", "album", playingData)
  label = list.assoc(default="", "label", playingData)

  if (artist != "") then
    playingString = "#{artist} - #{title}"

    # If the currently playing track isn't the same as on last poll:
    if (playingString != last_name) then
      # Update last displayed track title
      last_creek_track := (playingString, now)

      # Chaged metadata so update source metadata as 'new track'
      creek_metadata_source.insert_metadata(new_track=true, [("title", playingString)])

        # Scrobble new tracks to Last.FM
      lastfm.scrobble(artist=artist, album=album, track=title)

      # Log Now Playing to TuneIn AIR API
      tunein.nowPlaying(artist=artist, track=title, album=album)

      # Log to Slack
      slack.log(channel="now_playing", ":notes: #{artist} - #{title} (#{album}) [#{label}]")
    end
  else
    # No track: Display the current show/host/station
    show = bff.fetch(cacheBust=true, "data/shows/now.text")

    # Generally, BFF.fm should always have a show in the schedule (even placeholders), but
    # just in case there's a gap, or a data error, fall back to
    show = if (show == "") then
      "BFF.fm"
    else
      show
    end

    if (show != last_name) then
      # Update last displayed track title
      last_creek_track := (show, now)

      # Update source metadata, but not as a 'track'
      creek_metadata_source.insert_metadata(new_track=false, [("title", show)])

      # Log to Slack
      slack.log(channel="now_playing", ":radio: #{show}")

      # Log Now Playing 'commerical'/non-music to TuneIn
      # Split Artist - Name format and send to AIR
      # TODO: Might be cleaner with a JSON response from Creek
      parts = list.map(string.trim, string.split(separator="-", show))
      if (list.length(parts) == 2) then
        attribution = list.hd(default="", parts)
        name = list.nth(default="", parts, 1)
        tunein.nonMusic(attribution=attribution, name=name)
      end
    end
  end

  # Return the timeout for the next poll
  (10.)
end

add_timeout(fast=false, 10., poll_creek_metadata)

emergency_broadcast = ingest.makeStudioSource("Emergency Broadcast", mount="/emergency", username="ebs", password="44qX942NMq7vKQzEUTdAB7FZGpKRY4yW")

# Add the no-ice metadata stream to the stack before the global metadata listener
radio = fallback(track_sensitive=false, [emergency_broadcast, dj_sources, radio])

### END: BFF.fm Ingest Harbors ###

# Send metadata changes back to AzuraCast
def metadata_updated(m) =
    def f() =
        if (m["song_id"] != "") then
            ret = list.hd(get_process_lines(env=[("SONG", m["song_id"]), ("MEDIA", m["media_id"]), ("PLAYLIST", m["playlist_id"]), ("API_AUTH", !azuracast_api_auth)], 'curl -s --request POST --url http://web/api/internal/5/feedback --form song="$SONG" --form media="$MEDIA" --form playlist="$PLAYLIST" --form api_auth="$API_AUTH"'), default="")
            log("AzuraCast Feedback Response: #{ret}")
        end
        (-1.)
    end

    add_timeout(fast=false, 0., f)
end

radio = on_metadata(metadata_updated,radio)

# Local Broadcasts
output.icecast(%mp3(samplerate=44100, stereo=true, bitrate=128, id3v2=true), id="local_1", host = "127.0.0.1", port = 8010, password = "(PASSWORD)", mount = "/radio.mp3", name = "Test Frequencies Forever", description = "A test instance station for config adjustments, trial runs, miscillaneous noodling.", genre = "Unclassifiable", url = "https://bff.fm", public = false, encoding = "UTF-8", radio)

# Remote Relays
